import os
import yaml
import warnings
import requests
import urllib3
from abc import ABC
from pathlib import Path
from typing import Dict, Union, List, Any
from v3io.dataplane import Client


class BaseDeployer:

    """
    Deployers handle the actual yaml parsing and deployment - they should be named through semantic versioning
    """
    def __init__(self):
        self.client: Union[DeployerClient, None] = None
        self.recreate_data = False
        self.include_functions = None
        self.credentials = None

    def setup_streams(self) -> Dict[str, Any]:
        """
        Method for setting up streams found in the inference graph, should use client for creation implementation

        For inference graph API for streams, reference the associated yaml file under utils/api<APIcode>

        Returns
        -------
        Dict of stream specifications - name, shards, retention, path, container, etc.
        """
        raise NotImplementedError

    def setup_functions(self, stream_specs: Dict) -> None:
        """
        Method for setting up functions found in the inference graph, should use client for creation implementation

        For inference graph API for functions, reference the associated yaml file under utils/api<APIcode>

        Parameters
        ----------
        stream_specs: dict
            Dictionary containing stream specifications generated by setup streams

        Returns
        -------
        None
        """
        raise NotImplementedError

    def __call__(self, dry_run: bool = False, *args, **kwargs) -> Union[None, List[str]]:
        """
        Invoke a deployment, optionally describe deployment plan

        Parameters
        ----------
        dry_run: bool, optional
            Boolean indicating if the deployment should return a list of commands describing the deployment plan

        Returns
        -------
        None or list of deployment steps if dry_run

        """
        if self.recreate_data:
            warnings.warn('Recreating data will delete ALL functions before the data is recreated')
            if self.include_functions is not None:
                warnings.warn(f'Only the following functions will be restored {self.include_functions}')

        self.client = IguazioClient(self.credentials) if not dry_run else DryRunClient(self.credentials)
        stream_specs = self.setup_streams()
        self.setup_functions(stream_specs)
        print('Deployment complete')
        return self.client.dry_run if dry_run else None

    @staticmethod
    def _read_inference_graph(path: Union[str, Path]) -> Dict:
        """
        Helper method to load an inference graph yaml file

        Parameters
        ----------
        path: str or pathlib.Path
            Path to the inference graph yaml

        Returns
        -------
        dict which contains all of the inference configuration
        """
        with open(path, 'r') as f:
            return yaml.safe_load(f)

    @staticmethod
    def _sluggify_name(name: str) -> str:
        """
        Converts strings to slug case, using -

        Parameters
        ----------
        name: str
            String to convert

        Returns
        -------
        string which has been converted to slug case
        """
        return name.lower().strip().replace(" ", "-").replace("_", "-")

    @staticmethod
    def _snakeify_name(name: str) -> str:
        """
        Converts strings to snake case, using _

        Parameters
        ----------
        name: str
            String to convert

        Returns
        -------
        string which has been converted to snake case
        """
        return name.lower().strip().replace(" ", "_").replace("-", "_")

    def _make_stream_path(self, project_name: str, stream_name: str) -> str:
        """
        Helper method for consistent stream paths

        Parameters
        ----------
        project_name: str
            Name of the project
        stream_name: str
            Name of the stream

        Returns
        -------
        String that will be used for the stream path
        """
        return f'/{project_name}/streams/{self._sluggify_name(stream_name)}'


class DeployerClient(ABC):
    """
    Abstract base class for deployer clients that decouple function and stream creation from deployers
    """

    def create_stream(self, stream_name: str, stream_spec: Dict) -> None:
        """
        Method for creating a stream

        Parameters
        ----------
        stream_name: str
            Name of the stream to be created - not the path
        stream_spec: dict
            Specifications for the stream including container, path, shards, keys, retention, etc.

        Returns
        -------
        None
        """
        pass

    def delete_stream(self, stream_name: str, stream_spec: Dict) -> None:
        """
        Method for deleting a stream

        Parameters
        ----------
        stream_name: str
            Name of the stream to be deleted - not the path
        stream_spec: dict
            Specifications for the stream including container, path, shards, keys, retention, etc.

        Returns
        -------
        None
        """
        pass

    def create_function(self,  name: str, project_name: str, mlrun_function) -> None:
        """
        Method for creating a function

        Parameters
        ----------
        name: str
            name of the function
        project_name: dict
            name of the containing project for the function
        mlrun_function
            MLRun function specification

        Returns
        -------
        None
        """
        pass

    def delete_function(self,  name: str, project_name: str) -> None:
        """
        Method for deleting a function

        Parameters
        ----------
        name: str
            name of the function
        project_name: dict
            name of the containing project for the function

        Returns
        -------
        None
        """
        pass


class IguazioClient(DeployerClient):

    def __init__(self, credentials: Union[Dict[str, str], None]):
        self.client = Client()
        self.credentials = credentials

    def create_stream(self, stream_name: str, stream_spec: Dict) -> None:
        try:
            self.client.stream.create(
                container=stream_spec['container'],
                stream_path=stream_spec['path'],
                shard_count=stream_spec['shards'],
                access_key=os.environ['V3IO_ACCESS_KEY'],
                retention_period_hours=stream_spec['retention'],
                raise_for_status=[200, 204, 409]  # 409 is stream already exists
            )
        except Exception as e:
            raise Exception(f'Stream creation for stream {stream_name} failed with error: {e}')

    def delete_stream(self, stream_name: str, stream_spec: Dict) -> None:

        try:
            self.client.stream.delete(
                container=stream_spec['container'],
                stream_path=stream_spec['path'],
                access_key=os.environ['V3IO_ACCESS_KEY'],
                raise_for_status=[200, 204, 404, 400]  # don't worry if nothing to delete
            )
        except Exception as e:
            raise Exception(f'Stream deletion for stream {stream_name} failed with error: {e}')

    def create_function(self, name: str, project_name: str, mlrun_function) -> None:
        try:
            address = mlrun_function.deploy()
            print(f'Function {name} was deployed into project {project_name} at {address}')
        except Exception as e:
            raise Exception(f'Function {name} failed to deploy with error: {e}')

    def delete_function(self, name: str, project_name: str) -> None:
        warnings.warn('Deleting functions is reserved for on cluster due to internal DNS requirements')

        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        session = requests.Session()
        try:
            session.auth = (self.credentials['username'], self.credentials['password'])
        except KeyError as e:
            raise Exception(f'To delete functions, which is required for stream recreation, you must set credentials '
                            f'in the environment as IGUAZIO_USERNAME and IGUAZIO_PASSWORD: {e} is missing')

        api_url = 'https://datanode-dashboard/api'
        auth = session.post(f'{api_url}/sessions', verify=False)
        function_name = f'{project_name}-{name}'
        response = session.delete(f'{api_url}/functions/{function_name}')

        if not response.ok:
            raise Exception(f'Function deletion failed with code {response.status_code} and message {response.text}')


class DryRunClient(DeployerClient):

    def __init__(self, credentials: Union[Dict[str, str], None]):
        _ = credentials
        self.dry_run = {'streams': {'delete': {}, 'create': {}},
                        'functions': {'delete': {}, 'create': {}},
                        'ordered': []}

    def _add_command(self, cmd: Dict, action: str, kind: str):
        """
        Helper for adding commands to the dry run attribute and printing out

        Parameters
        ----------
        cmd: dict
            Dictionary of keys important for creation or deletion
        action: str
            Create or delete
        kind:
            Stream or function

        Returns
        -------
        None
        """

        human_readable = f'{action.title()} {kind} {cmd}'
        print(human_readable)

        self.dry_run.get(f'{kind}s').get(action).update(cmd)
        self.dry_run.get('ordered').append(human_readable)

    def create_stream(self, stream_name: str, stream_spec: Dict) -> None:

        cmd = {stream_name: stream_spec}
        self._add_command(cmd, 'create', 'stream')

    def delete_stream(self, stream_name: str, stream_spec: Dict) -> None:
        cmd = {stream_name: stream_spec}
        self._add_command(cmd, 'delete', 'stream')

    def create_function(self, name: str, project_name: str, mlrun_function) -> None:

        cmd = {name: {'project': project_name, 'mlrun_spec': mlrun_function.to_dict()}}
        self._add_command(cmd, 'create', 'function')

    def delete_function(self, name: str, project_name: str) -> None:
        cmd = {name: {'project': project_name}}
        self._add_command(cmd, 'delete', 'function')
